<!doctype html> <html lang=en> <head> <meta charset=utf-8 /> <title>Ruby on Rails 6: Week 5 — ejelome</title> <meta content="Ruby on Rails 6: Week 5" name=title /> <meta content="Week 5 summary of the learned lessons from The Pragmatic Studio's Ruby on Rails 6 course." name=description /> <meta content=ejelome name=author /> <meta content="width=device-width,initial-scale=1" name=viewport /> <link href=/img/favicon.ico rel="shortcut icon" type=image/x-icon /> <link href=https://ejelome.com/blog/ruby-on-rails-6-week-5 rel=canonical /> <script>var script=document.createElement("script");function gtag(){dataLayer.push(arguments)}script.src="//googletagmanager.com/gtag/js?id=UA-144170438-1",document.head.appendChild(script),window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-144170438-1")</script> <script src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js async data-ad-client=ca-pub-3560971753878587></script> <link href=/css/styles.css rel=stylesheet /> </head> <body class=posts> <div class=wrapper> <div class=header> <a href=/ class=navbar-brand> <img alt=ejelome class=site-logo height=64 src=/img/logo.png width=64 /> </a> <div class=site-info> <a href=/ class=site-title>ejelome</a> <p class=site-tagline>Research, Design and Development</p> </div> <ul class=social-media> <li class=github> <a href=https://github.com/ejelome class=btn data-placement=top data-toggle=tooltip title="GitHub Profile" rel=nofollow> <i class="fa-2x fab fa-github"> </i> </a> </li> <li class=youtube> <a href=https://www.youtube.com/channel/UCgqy7fcflZb5hhfLAUmlc5g class=btn data-placement=top data-toggle=tooltip title="Youtube Channel" rel=nofollow> <i class="fa-2x fab fa-youtube"> </i> </a> </li> <li class=linkedin> <a href=https://linkedin.com/in/ejelome class=btn data-placement=top data-toggle=tooltip title="LinkedIn Profile" rel=nofollow> <i class="fa-2x fab fa-linkedin"> </i> </a> </li> </ul> </div> <div class=siri-container> </div> <div class="nav site-nav"> <ul class=list-inline> <li class=list-inline-item> <a href=/ >Home</a> </li> <li class=list-inline-item> <a href=/about>About</a> </li> <li class=list-inline-item> <a href=/archives>Archives</a> </li> </ul> </div> <div class="breadcrumb breadcrumbs"> <a href=/ >Home</a> <span class=separator> <i class="separator fa-caret-right fas"> </i> </span> <a href=/blog>Blog</a> <span class=separator> <i class="separator fa-caret-right fas"> </i> </span> <strong class=active>Ruby on Rails 6: Week 5</strong> </div> <div class=main> <div class=sidebar> <div class="sticky-top toc"> <strong>Table of Contents</strong> </div> </div> <div class=content> <h1>Ruby on Rails 6: Week 5</h1> <div class=post-content> <div class=post-meta> <span class=author> <i class="fas fa-user"> </i> <a href=/about#about data-toggle=tooltip data-placement=top>ejelome</a> </span> <span class=separator>/</span> <span class=published> <i class="fa-clock far"> </i> <time data-placement=top data-toggle=tooltip datetime=2019-11-10T00:00Z title="Published Date">November 10, 2019</time>  <span class=separator>/</span> <span class=tags> <i class="fas fa-tags"> </i> <a href=/tags/research class=tag data-placement=top data-toggle=tooltip title="Posts tagged with research">research</a> <span class=separator>▪</span> <a href=/tags/ruby class=tag data-placement=top data-toggle=tooltip title="Posts tagged with ruby">ruby</a> <span class=separator>▪</span> <a href=/tags/ruby-on-rails class=tag data-placement=top data-toggle=tooltip title="Posts tagged with ruby-on-rails">ruby-on-rails</a> <span class=separator>▪</span> <a href=/tags/web-application-framework class=tag data-placement=top data-toggle=tooltip title="Posts tagged with web-application-framework">web-application-framework</a> </span> </div> <div class="jumbotron post-summary"> <h2>Summary</h2> <p> This document is the continuation of Ruby on Rails 6: Week 4 and will be about 1) many-to-many associations, 2) through associations, 3) custom scopes and routes, 4) friendly urls and callbacks and 5) deployment. </p> </div> <hr/> <div class=content-block> <p><strong>Note:</strong> This is the continuation of <a href=ruby-on-rails-6-week-4 rel=nofollow>Ruby on Rails 6: Week 4</a>.</p><p>This document will be the week 5 summary, the last week, of the learned lessons from <a href=https://pragmaticstudio.com rel=nofollow>The Pragmatic Studio</a>'s <a href=https://pragmaticstudio.com/courses/rails rel=nofollow>Ruby on Rails 6</a> course.</p><h2>Many-to-many Associations</h2><p><strong>Notes:</strong></p><ul><li>A join model should have two foreign keys</li><li><code>&lt;model_1>_id</code> references a row in the <code>&lt;model_1></code>'s table</li><li><code>&lt;model_2> id</code> references a row in the <code>&lt;model_2></code>'s table</li><li>The join model uses <i>one-to-many</i> (<code>belongs_to</code>) relationship to connect the two models</li><li>The joined models uses <i>many-to-many</i> (<code>has_many</code>) relationship to connect to the join model</li><li>Create a new migration:<pre><code class=shell>$ rails g migration ChangeTagsToJoinTable
Running via Spring preloader in process 10644
      invoke  active_record
      create    db/migrate/20191110140201_change_tags_to_join_table.rb
</code></pre></li><li>Update migration file:<pre><code class=ruby># File: db/migrate/&lt;timestamp>_change_tags_to_join_table.rb
class ChangeTagsToJoinTable &lt; ActiveRecord::Migration[6.0]
  def change
    add_column :tags, :user_id, :integer
    Tag.delete_all
  end
end
</code></pre> <strong>Notes:</strong><ul><li>The <code>add_column</code> method takes three parameters (table, new column, and column type)</li><li>The model name referenced should be singular followed by <code>_id</code> suffix (e.g. <code>user_id</code>)</li><li>The <code>delete_all</code> method, without parameters, removes all the records of the mapped table</li><li>The column type must be provided to be able to roll back a dropped table</li></ul></li><li>Apply migration:<pre><code class=shell>$ rails db:migrate
</code></pre></li><li>Update the models:<pre><code class=ruby># File: app/models/tag.rb
class Tag &lt; ApplicationRecord
  ...
  belongs_to :user
  ...
end
</code></pre><pre><code class=ruby># File: app/models/user.rb
class User &lt; ApplicationRecord
  has_many :tags, dependent: :destroy
  ...
end
</code></pre><pre><code class=ruby># File: app/models/page.rb
class User &lt; ApplicationRecord
  has_many :tags, dependent: :destroy
  ...
end
</code></pre></li><li>Open Rails console:<pre><code class=shell>$ rails c
</code></pre></li><li>Check that associations exists:<pre><code class=shell> > Tag.column_names
=> ["id", "name", "page_id", ... "user_id"]
</code></pre> <strong>Note:</strong> The <code>page_id</code> and <code>user_id</code> are the associations to <code>Page</code> and <code>User</code> models.</li><li>Test the associations:<pre><code class=ruby> > tag = Tag.new(name: "hashtag")
  (0.4ms)  SELECT sqlite_version(*)
=> #&lt;Tag id: nil, name: "hashtag", page_id: nil, ... user_id: nil>

 > tag.user
=> nil

 > tag.page
=> nil
</code></pre> <strong>Note:</strong> Both <code>tag.user</code> and <code>tag.page</code> currently returns <code>nil</code> since their models aren't yet attached.</li><li>Associate a page and user:<pre><code class=ruby> > user = User.create(username: "foo", password: "bar")
   (0.1ms)  begin transaction
   User Exists? (0.2ms)  SELECT 1 AS one FROM "users" ...
   User Create (0.2ms)  INSERT INTO "users" ...
   (11.8ms)  commit transaction
=> #&lt;User id: 1, username: "foo", ...

 > tag.user = user
=> #&lt;User id: 1, username: "foo", ...

 > page = Page.create(title: "Hello World!", message: "Halo there!")
   (0.1ms)  begin transaction
   Page Create (0.5ms)  INSERT INTO "pages" ...
   (10.9ms)  commit transaction
=> #&lt;Page id: 1, title: "Hello World!", ...

 > tag.page = page
=> #&lt;Page id: 3, title: "Hello World!", ...

 > tag.save
   (0.2ms)  begin transaction
   Tag Create (0.7ms)  INSERT INTO "tags" ...
   (35.5ms)  commit transaction
=> true
</code></pre> <strong>Note:</strong> The <code>belongs_to</code> returns the direct associated entity (row).</li><li>Test association of page and user the other way:<pre><code class=ruby> > user = User.find_by(username: "foo")
   User Load (0.4ms)  SELECT "users".* FROM "users" ...
=> #&lt;User id: 1, username: "foo", ...
 > user.tags
   Tag Load (0.3ms)  SELECT "tags".* FROM "tags" ...
=> #&lt;ActiveRecord::Associations::CollectionProxy [#&lt;Tag id: 1, name: "hashtag", ...

 > page = Page.find_by(title: "Hello World!")
   Page Load (0.2ms)  SELECT "pages".* FROM "pages" ...
=> #&lt;Page id: 1, title: "Hello World!", ...
 > page.tags
   Tag Load (0.2ms)  SELECT "tags".* FROM "tags" ...
=> #&lt;ActiveRecord::Associations::CollectionProxy [#&lt;Tag id: 1, name: "hashtag", ...
</code></pre> <strong>Note:</strong> The <code>has_many</code> returns an array of associated entities (rows).</li></ul><h2>Through Associations</h2><h3 id=through>through</h3><p><strong>Note:</strong> The <code>through</code> option is used to bypass the join model and access the other end model.</p><ol><li>Access user from page:<pre><code class=ruby> > page = Page.find_by(title: "Hello World!")
   Page Load (0.1ms)  SELECT "pages".* FROM "pages" ...
=> #&lt;Page id: 1, ...
 > page.tags.each { |tag| tag.user.username }
  Tag Load (0.1ms)  SELECT "tags".* FROM "tags" ...
  User Load (0.1ms)  SELECT "users".* FROM "users" ...
=> [#&lt;Tag id: 1, name: "hashtag", page_id: 1, ... user_id: 1>]
</code></pre> <strong>Note:</strong> Notice that it required two database hits (1 from <code>tag</code> and 1 from <code>user</code>).</li><li>Access page from user:<pre><code class=ruby> > user = User.find_by(username: "foo")
   User Load (0.1ms)  SELECT "users".* FROM "users" ...
=> #&lt;User id: 1, username: "foo", ...
 > user.tags.each { |tag| tag.page.title }
   Tag Load (0.1ms)  SELECT "tags".* FROM "tags" ...
   Page Load (0.1ms)  SELECT "pages".* FROM "pages" ...
=> [#&lt;Tag id: 1, name: "hashtag", page_id: 1, ... user_id: 1>]
</code></pre> <strong>Note:</strong> This should have same effect as above.</li><li>Update the models:<pre><code class=ruby># File: app/models/page.rb
class Page &lt; ApplicationRecord
  ...
  has_many :users, through: :tags
  ...
end
</code></pre><pre><code class=ruby># File: app/models/user.rb
class User &lt; ApplicationRecord
  ...
  has_many :pages, through: :tags
  ...
end
</code></pre></li><li>Open Rails console:<pre><code class=shell>$ rails c
</code></pre></li><li>Access user from page:<pre><code class=ruby> > page = Page.find_by(title: "Hello World!")
   Page Load (0.1ms)  SELECT "pages".* FROM "pages" ...
=> #&lt;Page id: 1, title: "Hello World!", ...
 > page.users
   User Load (0.1ms)  SELECT "users".* FROM "users" ...
=> #&lt;ActiveRecord::Associations::CollectionProxy [#&lt;User id: 1, ...
</code></pre></li><li>Access page from user:<pre><code class=ruby> > user = User.find_by(username: "foo")
   User Load (0.2ms)  SELECT "users".* FROM "users" ...
=> #&lt;User id: 1, username: "foo", ...
 > user.pages
   Page Load (0.2ms)  SELECT "pages".* FROM "pages" ...
=> #&lt;ActiveRecord::Associations::CollectionProxy [#&lt;Page id: 1, ...
</code></pre></li></ol><p><strong>Note:</strong> Not only the other model can be accessed easily, it also hits the database only once.</p><h3 id=source>source</h3><p><strong>Note:</strong> The <code>source</code> option allows renaming of the models being associated.</p><ol><li>Update the models:<pre><code class=ruby># File: app/models/page.rb
class Page &lt; ApplicationRecord
  ...
  has_many :authors, through: :tags, source: :user
  ...
end
</code></pre><pre><code class=ruby># File: app/models/user.rb
class User &lt; ApplicationRecord
  ...
  has_many :posts, through: :tags, source: :page
  ...
end
</code></pre> <strong>Notes:</strong><ul><li>The alias is plural (<code>:authors</code>, <code>:posts</code>)</li><li>The <code>source</code> is singular (<code>:user</code>, <code>:page</code>)</li></ul></li><li>Open Rails console:<pre><code class=shell>$ rails c
</code></pre></li><li>Access user from page:<pre><code class=ruby> > page = Page.find_by(title: "Hello World!")
   (0.1ms)  SELECT sqlite_version(*)
   Page Load (0.2ms)  SELECT "pages".* FROM "pages" ...
=> #&lt;Page id: 1, title: "Hello World!", ...
 > page.authors
   User Load (0.1ms)  SELECT "users".* FROM "users" ...
=> #&lt;ActiveRecord::Associations::CollectionProxy [#&lt;User id: 1, ...
</code></pre></li><li>Access page from user:<pre><code class=ruby> > user = User.find_by(username: "foo")
   User Load (0.2ms)  SELECT "users".* FROM "users" ...
=> #&lt;User id: 1, username: "foo", ...
 > user.posts
   Page Load (0.2ms)  SELECT "pages".* FROM "pages" ...
=> #&lt;ActiveRecord::Associations::CollectionProxy [#&lt;Page id: 1, ...
</code></pre></li></ol><h3 id=checkboxes>Checkboxes</h3><p>An example of implementing many-to-many relationship on checkboxes.</p><ol><li>Create a new resource:<pre><code class=shell>$ rails g resource category title
</code></pre></li><li>Apply migration:<pre><code class=shell>$ rails db:migrate
</code></pre></li><li>Update the model:<pre><code class=ruby># File: app/models/category.rb
class Category &lt; ApplicationRecord
  validates :title, presence: true, uniqueness: true
end
</code></pre></li><li>Create a join model:<pre><code>$ rails g model categorization page:references category:references
Running via Spring preloader in process 10482
      invoke  active_record
      create    db/migrate/&lt;timestamp>_create_categorizations.rb
      create    app/models/categorization.rb
      invoke    test_unit
      create      test/models/categorization_test.rb
      create      test/fixtures/categorizations.yml
</code></pre> <strong>Note:</strong> <code>&lt;model>:references</code> will resolve to <code>&lt;model>_id</code> as foreign keys.</li><li>Apply migration:<pre><code class=shell>$ rails db:migrate
</code></pre></li><li>Update the associated models:<pre><code class=ruby># File: app/models/page.rb
class Page &lt; ApplicationRecord
  ...
  has_many :categorizations, dependent: :destroy
  has_many :categoris, through: :categorizations
  ...
end
</code></pre><pre><code class=ruby># File: app/models/category.rb
class Category &lt; ApplicationRecord
  ...
  has_many :categorizations, dependent: :destroy
  has_many :pages, through: :categorizations
  ...
end
</code></pre></li><li>Open Rails console:<pre><code class=shell>$ rails c
</code></pre></li><li>Test the associations:<ol><li>Create categories:<pre><code class=ruby> > Category.create([
     {title: "Music"},
     {title: "Art"},
     {title: "Math"},
     {title: "Sports"},
     {title: "Philosophy"},
     {title: "Science"}
 ])
    (0.6ms)  SELECT sqlite_version(*)
    (0.1ms)  begin transaction
   Category Exists? (0.3ms)  SELECT 1 AS one FROM "categories" ...
   Category Create (0.3ms)  INSERT INTO "categories" ("title", ...
    (10.1ms)  commit transaction
    (0.1ms)  begin transaction
   Category Exists? (0.2ms)  SELECT 1 AS one FROM "categories" ...
   Category Create (0.2ms)  INSERT INTO "categories" ("title", ...
    (9.6ms)  commit transaction
    (0.1ms)  begin transaction
   Category Exists? (0.2ms)  SELECT 1 AS one FROM "categories" ...
   Category Create (0.2ms)  INSERT INTO "categories" ("title", ...
    (9.3ms)  commit transaction
    (0.1ms)  begin transaction
   Category Exists? (0.2ms)  SELECT 1 AS one FROM "categories" ...
   Category Create (0.2ms)  INSERT INTO "categories" ("title", ...
    (8.3ms)  commit transaction
    (0.1ms)  begin transaction
   Category Exists? (0.2ms)  SELECT 1 AS one FROM "categories" ...
   Category Create (0.3ms)  INSERT INTO "categories" ("title", ...
    (9.4ms)  commit transaction
    (0.1ms)  begin transaction
   Category Exists? (0.2ms)  SELECT 1 AS one FROM "categories" ...
   Category Create (0.2ms)  INSERT INTO "categories" ("title", ...
    (9.7ms)  commit transaction
=> [#&lt;Category id: 1, title: "Music", ...
</code></pre></li><li>Associate a category to a page:<pre><code class=ruby> > page = Page.find_by(title: "Hello World!")
   Page Load (0.2ms)  SELECT "pages".* FROM "pages" ...
=> #&lt;Page id: 1, title: "Hello World!", ...
 > category = Category.find_by(title: "Philosophy")
   Category Load (0.5ms)  SELECT "categories".* FROM "categories" ...
=> #&lt;Category id: 5, title: "Philosophy", ...
 > page.categories &lt;&lt; category
   (0.2ms)  begin transaction
   Categorization Create (1.0ms)  INSERT INTO "categorizations" ...
   (10.9ms)  commit transaction
   Category Load (0.2ms)  SELECT "categories".* FROM "categories" ...
=> #&lt;ActiveRecord::Associations::CollectionProxy [#&lt;Category id: 5, title: "Philosophy", ...
</code></pre> <strong>Note:</strong> <code>&lt;&lt;</code> is a shortcut for <code>push</code> method (e.g. <code>page.categories.push(category)</code>).</li><li>Associate categories thru <code>&lt;model>_ids</code>:<pre><code class=ruby> > page.category_ids = [1, 2, 5]
   Category Load (0.8ms)  SELECT "categories".* FROM "categories" ...
   Category Load (0.5ms)  SELECT "categories".* FROM "categories" ...
   (0.2ms)  begin transaction
   Categorization Create (0.8ms)  INSERT INTO "categorizations" ...
   Categorization Create (0.4ms)  INSERT INTO "categorizations" ...
   (34.1ms)  commit transaction
 => [1, 2, 5]
2.6.3 :016 >
</code></pre> <strong>Note:</strong> Assign an array containing IDs <code>category_ids</code> attribute.</li><li>Empty associated categories with an empty array (<code>[]</code>):<pre><code class=ruby> > page.category_ids = []
   Category Load (0.5ms)  SELECT "categories".* FROM "categories" ...
   (0.2ms)  begin transaction
   Categorization Destroy (0.9ms)  DELETE FROM "categorizations" ...
   (35.2ms)  commit transaction
=> []
</code></pre></li></ol></li><li>Update partial view (<code>_form</code>):<pre><code class=ruby>&lt;%# File: app/views/pages/_form.html.erb %>
&lt;%= form_with(model: page, local: true) do |form| %>
    ...
    &lt;%= form.collection_check_boxes(:category_ids, Category.all, :id, :title) %>
    ...
&lt;% end %>
</code></pre></li><li>Update the controller:<pre><code class=ruby># File: app/controllers/pages_controller.rb
class PagesController &lt; ApplicationController
  ...
  def page_params
    params.require(:page).permit(
      ...
      category_ids: []
    )
  end
end
</code></pre> <strong>Notes:</strong><ul><li><code>category_ids</code> is not a keyword</li><li>It must have an empty array as initial value</li></ul></li></ol><h2>Custom Scopes and Routes</h2><p><strong>Notes:</strong></p><ul><li><code>scope</code> allows for naming a query (e.g. <code>:recent</code>)</li><li><code>scope</code>s can be chained with other <code>scope</code>s</li><li><code>scope</code> names can be called by either the model or associated objects</li><li>Chained <code>scope</code>s only executes a single database query</li></ul><p></p><ol><li>Update the model:<ul><li>Without arguments:<pre><code class=ruby># File: app/models/category.rb
class Category &lt; ApplicationRecord
  ...
  scope :recent, -> { where("created_at &lt; ?", Time.now).order("id desc") }
end
</code></pre> <strong>Note:</strong> <code>-></code> is a shortcut for <code>lambda</code> that wraps a block for later use (lazy evaluated).</li><li>With Arguments:<pre><code class=ruby># File: app/models/category.rb
class Category &lt; ApplicationRecord
  ...
  scope :recent, ->(n=5) { where("created_at &lt; ?", Time.now).order("id desc").limit(n) }
  scope :contains, ->(s="") { where("title LIKE ?", "%#{s}%") .all }
end
</code></pre></li></ul></li><li>Open Rails console:<pre><code class=shell>$ rails c
</code></pre></li><li>Invoke <code>scope</code> name:<pre><code class=ruby> > # Without arguments:
 > Category.recent
   Category Load (0.5ms)  SELECT "categories".* FROM "categories" ...
=> #&lt;ActiveRecord::Relation [#&lt;Category id: 6, ...
 > Category.recent.size
   (0.4ms)  SELECT COUNT(*) FROM (SELECT 1 AS one FROM "categories" ...
=> 5

 > # With arguments:
 > Category.recent(3)
   Category Load (0.5ms)  SELECT "categories".* FROM "categories" ...
=> #&lt;ActiveRecord::Relation [#&lt;Category id: 6, title: "Science", ...
 > Category.recent(3).size
   (0.6ms)  SELECT COUNT(*) FROM (SELECT 1 AS one FROM "categories" ...
=> 3
</code></pre></li><li>Chaining <code>scope</code>s:<pre><code class=ruby> > Category.recent(3).contains("P")
   Category Load (0.2ms)  SELECT "categories".* FROM "categories" ...
=> #&lt;ActiveRecord::Relation [#&lt;Category id: 5, title: "Philosophy", ...
 > Category.recent(3).contains("P").size
   (0.5ms)  SELECT COUNT(*) FROM (SELECT 1 AS one FROM "categories" ...
=> 2
</code></pre></li><li>Call by an associated object:<pre><code class=ruby> > page = Page.find_by(title: "Hello World!")
   Page Load (0.6ms)  SELECT "pages".* FROM "pages" ...
=> #&lt;Page id: 1, title: "Hello World!", ...
 > page.categories.contains("s")
   Category Load (0.7ms)  SELECT "categories".* FROM "categories" ...
=> #&lt;ActiveRecord::AssociationRelation [#&lt;Category id: 1, title: "Music", ...
 > page.categories.contains("s").size
   (0.5ms)  SELECT COUNT(*) FROM "categories" ...
=> 2
</code></pre></li><li>Using <code>lambda</code> on model:<pre><code class=ruby># File: app/models/category.rb
class Category &lt; ApplicationRecord
  has_many :categorizations, -> { order(created_at: :desc) }, dependent: :destroy
  ...
end
</code></pre> <strong>Note:</strong> <code>lambda</code>s can be used as a second parameter on <code>has_many</code> method.</li></ol><h2>Friendly URLs and Callbacks</h2><p><strong>Notes:</strong></p><ul><li>A friendly URL (a.k.a. vanity URL) is a URL that is both descriptive and memorable</li><li>Instead of using numbers to represent entities, a human-readable equivalent is used</li></ul><p></p><ol><li>Create a new migration: <br/><strong>Note:</strong> Add a slug column to store the human-readable equivalent of the entity.<pre><code class=shell>$ rails g migration AddSlugToPages slug
Running via Spring preloader in process 14838
      invoke  active_record
      create    db/migrate/20191112213418_add_slug_to_pages.rb
</code></pre></li><li>Apply migration:<pre><code class=shell>$ rails db:migrate
== 20191112213418 AddSlugToPages: migrating ===================================
-- add_column(:pages, :slug, :string)
   -> 0.0025s
== 20191112213418 AddSlugToPages: migrated (0.0026s) ==========================
</code></pre></li><li>Update the model:<pre><code class=ruby># File: app/models/page.rb
class Page &lt; ApplicationRecord
  before_save :set_slug
  ...
  validates :title, presence: true, uniqueness: true
  ...
  private

  def set_slug
    self.slug = title.parameterize
  end
end
</code></pre> <strong>Notes:</strong><ul><li>Make sure the column that the slug will refer to is unique (e.g. <code>.title</code>)</li><li>The <code>parameterize</code> method removes special characters from a string</li><li>The <code>parameterize</code> method, by default, separate words with a comma</li><li>The <code>parameterize</code> method, in this case, is used to make the friendly-URLs as slug</li><li>The <code>self</code> in <code>self.slug</code> indicates that it's an attribute not a local variable</li><li>The <code>self</code> in <code>self.slug</code> should only be used when writing to an attribute not when reading</li><li>The <code>before_save</code> method executes the callback (<code>set_slug</code>) before <code>save</code> (<code>create</code> or <code>update</code>)</li></ul></li><li>Open Rails console:<pre><code class=shell>$ rails c
</code></pre></li><li>Test the <code>before_save</code> callback:<pre><code class=ruby> > page = Page.create(title: "My Foo", message: "Foo bar baz")
   (0.1ms)  begin transaction
   Page Exists? (0.1ms)  SELECT 1 AS one FROM "pages" ...
   Page Create (0.3ms)  INSERT INTO "pages" ("title", "message", "created_at", "updated_at", "slug") VALUES (?, ?, ?, ?, ?)  [["title", "My Foo"], ["message", "Foo bar baz"], ["created_at", "2019-11-12 22:49:54.461300"], ["updated_at", "2019-11-12 22:49:54.461300"], ["slug", "my-foo"]]
   (8.6ms)  commit transaction
=> #&lt;Page id: 3, title: "My Foo", ...
 > page.slug
=> "my-foo"
</code></pre></li><li>Add slug on all of existing entities:<pre><code class=ruby>> Page.all.each { |p| p.save }
  Page Load (0.4ms)  SELECT "pages".* FROM "pages"
  (0.1ms)  begin transaction
  Page Exists? (0.2ms)  SELECT 1 AS one FROM "pages" ...
  Page Update (0.5ms)  UPDATE "pages" SET "slug" = ?, "updated_at" = ? ...
  (9.9ms)  commit transaction
  (0.1ms)  begin transaction
  Page Exists? (0.2ms)  SELECT 1 AS one FROM "pages" ...
  Page Update (0.3ms)  UPDATE "pages" SET "slug" = ?, "updated_at" = ? ...
  (8.4ms)  commit transaction
  (0.1ms)  begin transaction
  Page Exists? (0.2ms)  SELECT 1 AS one FROM "pages" ...
  (0.1ms)  commit transaction
=> [#&lt;Page id: 1, title: "Hello World!", ...
</code></pre></li><li>Check an attribute of all entities:<pre><code class=ruby> > Page.pluck(:slug)
   (0.9ms)  SELECT sqlite_version(*)
   (0.2ms)  SELECT "pages"."slug" FROM "pages"
=> ["hello-world", "crappy-world", "my-foo"]
</code></pre> <strong>Note:</strong> The <code>pluck</code> method returns an array from one or more specified attributes without loading all the records.</li><li>Test the <code>to_param</code> method:<pre><code class=ruby> > page.to_param
=> "3"
</code></pre> <strong>Note:</strong> The <code>to_param</code> method returns the entity ID that is used in the URLs.</li><li>Update the model:<pre><code class=ruby>class Page &lt; ApplicationRecord
  ...
  def to_param
    slug
  end

  private
  ...
end
</code></pre> <strong>Note:</strong> Override the <code>to_param</code> method use a slug instead of the default number.</li><li>Go back to console and test <code>to_param</code>:<pre><code class=ruby> > reload!
 Reloading...
=> true

 > page.to_param
=> "my-foo"

 > app.page_path(page)
=> "/pages/my-foo"
</code></pre></li><li>Update the controller:<pre><code class=ruby># File: app/controllers/pages_controller.rb
class PagesController &lt; ApplicationController
  before_action :set_page, exclude: [:index, :new, :create]
  ...
  private
  ...
  def set_page
    @page = Page.find_by(slug: params[:id])
  end
end
</code></pre> <strong>Notes:</strong><ul><li>Be sure to remove the occurence of <code>@page = Page.find(params[:id])</code> on resources with existing entity</li><li>The slug only applies to resource that contains an existing entity (hence, the <code>exclude</code>)</li></ul></li><li>Check that <code>/my-foo</code> works: <br/>Visit <a href=http://localhost:3000/pages/my-foo>http://localhost:3000/pages/my-foo</a>.</li></ol><h2>Deployment</h2><h3 id=environments>Environments</h3><table><thead><tr><th>Setup</th><th style=text-align:left>Development</th><th style=text-align:left>Production</th></tr></thead><tbody><tr><td>Config file</td><td style=text-align:left><code>config/environments/development.rb</code></td><td style=text-align:left><code>config/environments/production.rb</code></td></tr><tr><td>Database</td><td style=text-align:left>SQLite</td><td style=text-align:left>PostgreSQL</td></tr><tr><td>Logging</td><td style=text-align:left>Verbose</td></tr><tr><td>Auto-reload</td><td style=text-align:left>✔</td></tr><tr><td>Caching</td><td style=text-align:left>✔</td></tr><tr><td>Exceptions</td><td style=text-align:left>✔</td></tr><tr><td>Error Pages</td><td style=text-align:left>✔</td></tr><tr><td>Precompiled Assets</td><td style=text-align:left>✔</td></tr></tbody></table><p><strong>Notes:</strong></p><ul><li>Heroku auto-generates the <code>database.yml</code> that will be used with PostgreSQL database</li><li>^ there's no need to change the production environment settings in <code>config/database.yml</code></li></ul><h3 id=preparation>Preparation</h3><ol><li>Update the <code>Gemfile</code>:<ol><li>Put <code>sqlite3</code> gem in <code>development</code> and <code>test</code> group:<pre><code class=ruby>...
group :development, :test do
  gem 'sqlite3', '~> 1.4'
end
...
</code></pre></li><li>Add <code>pg</code> gem in <code>production</code> group: <br/><strong>Note:</strong> <code>pg</code> is an adapter to interact with a PostgreSQL database.<pre><code class=ruby>...
group :production do
  gem 'pg'
end
...
</code></pre></li></ol></li><li>Update the <code>Gemfile.lock</code>:<pre><code class=shell>$ bundle install --without production
</code></pre> <strong>Notes:</strong><ul><li>Installing the new gems will update the <code>Gemfile.lock</code> file</li><li>The <code>--without production</code> excludes gems to be installed in our local environment (<code>:development</code>)</li><li>Heroku uses the <code>Gemfile.lock</code> to install the gems (including <code>production</code> gems) when the app gets deployed</li><li>On production, assets should end with an extension (e.g. <code>image_tag("logo")</code> to <code>image_tag("logo.png")</code>)</li></ul></li></ol><h3 id=deployment>Deployment</h3><ol><li>Stage and commit files:<pre><code class=shell>$ \
git add -A
git commit -m 'Initial deployment'
</code></pre></li><li><a href=https://signup.heroku.com rel=nofollow>Sign up</a> (if not registered)</li><li>Install <a href=https://devcenter.heroku.com/articles/heroku-cli rel=nofollow>Heroku CLI</a></li><li>Log in (interactively):<pre><code class=shell>$ heroku login -i
heroku: Enter your login credentials
Email [username@domain.ext]:
Password: ************
Logged in as username@domain.ext
</code></pre> <strong>Notes:</strong><ul><li><code>-i</code> is a shortcut for <code>--interactive</code></li><li><code>-i</code> uses the terminal-based login flow instead of opening a web browser</li></ul></li><li>Create the Heroku repository:<pre><code class=shell>$ heroku create
Creating app... ⣾
Creating app... done, ⬢ &lt;app>
https://&lt;app>.herokuapp.com/ | https://git.heroku.com/&lt;app>.git
</code></pre> <strong>Note:</strong> <code>create</code> without any parameters creates a repo in Heroku with a random name.</li><li>Push the local changes to remote repo:<pre><code class=shell>$ git push heroku master
</code></pre> <strong>Notes:</strong><ul><li><code>master</code> is the branch we want to push from our local repo</li><li>Pushing to Heroku installs all the required gems (including the production gems)</li><li>^ It precompiles assets such as images, styles and scripts</li></ul></li><li>Apply migrations on production:<pre><code class=shell>$ heroku run rails db:migrate
</code></pre> <strong>Notes:</strong><ul><li><code>heroku run</code> executes a one-time process in a Heroku <code>&lt;app></code></li><li>An <code>&lt;app></code> in Heroku runs inside a container called a <strong>dyno</strong></li></ul></li><li>Apply seed data on production:<pre><code class=shell>$ heroku run rails db:seed
</code></pre></li><li>Open the <code>&lt;app></code> with the default browser:<pre><code class=shell>$ heroku open
</code></pre></li></ol><h3 id=heroku_commands>Heroku commands</h3><table><thead><tr><th style=text-align:left>Command</th><th style=text-align:left>Description</th></tr></thead><tbody><tr><td style=text-align:left><code>login</code></td><td style=text-align:left>Log in to Heroku (browser)</td></tr><tr><td style=text-align:left><code>login -i</code></td><td style=text-align:left>Log in to Heroku (shell)</td></tr><tr><td style=text-align:left><code>create</code></td><td style=text-align:left>Create a new Heroku app</td></tr><tr><td style=text-align:left><code>open</code></td><td style=text-align:left>Open Heroku app with default browser</td></tr><tr><td style=text-align:left><code>run</code></td><td style=text-align:left>Execute a one-time process in container</td></tr><tr><td style=text-align:left><code>apps</code></td><td style=text-align:left>List all of the Heroku apps</td></tr><tr><td style=text-align:left><code>ps</code></td><td style=text-align:left>Show the Heroku app status</td></tr><tr><td style=text-align:left><code>logs</code></td><td style=text-align:left>Show the Heroku app logs</td></tr><tr><td style=text-align:left><code>logs -t</code></td><td style=text-align:left>Show the Heroku app logs continuously</td></tr><tr><td style=text-align:left><code>rename</code></td><td style=text-align:left>Rename the Heroku app</td></tr><tr><td style=text-align:left><code>destroy</code></td><td style=text-align:left>Destroy the Heroku app</td></tr></tbody></table><p><strong>Congratulations!</strong> We've finally finished the course and learned enough <code>Ruby on Rails</code> :)</p> </div> </div> <div class=pagination> <a href=# class="btn btn-outline-secondary invisible previous"> <i class="fas fa-angle-left"> </i> </a> <a href=/blog/ruby-on-rails-custom-domain-and-ssl class="btn btn-outline-secondary next">Ruby on Rails: Custom Domain and SSL <i class="fas fa-angle-right"> </i> </a> </div> <hr/> <div class=post-comments> <h2>Comments</h2> <div id=disqus_thread> </div> <script>var disqus_config=function(){this.page.url="https://ejelome.com/blog/ruby-on-rails-6-week-5",this.page.identifier="Ruby on Rails 6: Week 5"};!function(){var e=document,t=e.createElement("script");t.src="//ejelome.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)}()</script> <noscript>Please enable JavaScript to view the <a href=//disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a> </noscript> </div> </div> </div> </div> <div class=footer> <p>Copyright © 2019 <a href=/ >ejelome</a>. Some rights reserved. </p> </div> <script src=/js/scripts.js></script> </body> </html> 