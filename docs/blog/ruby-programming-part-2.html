<!doctype html> <html lang=en> <head> <meta charset=utf-8 /> <title>Ruby Programming: Part 2 — ejelome</title> <meta content="Ruby Programming: Part 2" name=title /> <meta content="Page 2 of 4 summary of The Pragmatic Studio's 23-Day Course Plan of the Ruby Programming course." name=description /> <meta content=ejelome name=author /> <meta content="width=device-width,initial-scale=1" name=viewport /> <link href=/img/favicon.ico rel="shortcut icon" type=image/x-icon /> <link href=https://ejelome.com/blog/ruby-programming-part-2 rel=canonical /> <script>var script=document.createElement("script");function gtag(){dataLayer.push(arguments)}script.src="//googletagmanager.com/gtag/js?id=UA-144170438-1",document.head.appendChild(script),window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-144170438-1")</script> <script src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js async data-ad-client=ca-pub-3560971753878587></script> <link href=/css/styles.css rel=stylesheet /> </head> <body class=posts> <div class=wrapper> <div class=header> <a href=/ class=navbar-brand> <img alt=ejelome class=site-logo height=64 src=/img/logo.png width=64 /> </a> <div class=site-info> <a href=/ class=site-title>ejelome</a> <p class=site-tagline>Research, Design and Development</p> </div> <ul class=social-media> <li class=github> <a href=https://github.com/ejelome class=btn data-placement=top data-toggle=tooltip title="GitHub Profile" rel=nofollow> <i class="fa-2x fab fa-github"> </i> </a> </li> <li class=youtube> <a href=https://www.youtube.com/channel/UCgqy7fcflZb5hhfLAUmlc5g class=btn data-placement=top data-toggle=tooltip title="Youtube Channel" rel=nofollow> <i class="fa-2x fab fa-youtube"> </i> </a> </li> <li class=linkedin> <a href=https://linkedin.com/in/ejelome class=btn data-placement=top data-toggle=tooltip title="LinkedIn Profile" rel=nofollow> <i class="fa-2x fab fa-linkedin"> </i> </a> </li> </ul> </div> <div class=siri-container> </div> <div class="nav site-nav"> <ul class=list-inline> <li class=list-inline-item> <a href=/ >Home</a> </li> <li class=list-inline-item> <a href=/about>About</a> </li> <li class=list-inline-item> <a href=/archives>Archives</a> </li> </ul> </div> <div class="breadcrumb breadcrumbs"> <a href=/ >Home</a> <span class=separator> <i class="separator fa-caret-right fas"> </i> </span> <a href=/blog>Blog</a> <span class=separator> <i class="separator fa-caret-right fas"> </i> </span> <strong class=active>Ruby Programming: Part 2</strong> </div> <div class=main> <div class=sidebar> <div class="sticky-top toc"> <strong>Table of Contents</strong> </div> </div> <div class=content> <h1>Ruby Programming: Part 2</h1> <div class=post-content> <div class=post-meta> <span class=author> <i class="fas fa-user"> </i> <a href=/about#about data-toggle=tooltip data-placement=top>ejelome</a> </span> <span class=separator>/</span> <span class=published> <i class="fa-clock far"> </i> <time data-placement=top data-toggle=tooltip datetime=2019-08-25T00:00Z title="Published Date">August 25, 2019</time>  <span class=separator>/</span> <span class=tags> <i class="fas fa-tags"> </i> <a href=/tags/programming-language class=tag data-placement=top data-toggle=tooltip title="Posts tagged with programming-language">programming-language</a> <span class=separator>▪</span> <a href=/tags/research class=tag data-placement=top data-toggle=tooltip title="Posts tagged with research">research</a> <span class=separator>▪</span> <a href=/tags/ruby class=tag data-placement=top data-toggle=tooltip title="Posts tagged with ruby">ruby</a> </span> </div> <div class="jumbotron post-summary"> <h2>Summary</h2> <p> This document is the continuation of Ruby Programming: Part 1 and will be about 1) attributes, 2) arrays, 3) objects interacting, 4) separate source files, 5) unit testing and 6) conditionals & TDD. </p> </div> <hr/> <div class=content-block> <p><strong>Note:</strong> This is the continuation of <a href=ruby-programming-part-1 rel=nofollow>Ruby Programming: Part 1</a>.</p><p>This document will be the summary of page 2 from the course outline, <a href=https://pragmaticstudio.s3.amazonaws.com/courses/ruby/PragStudioRubyPlan.pdf rel=nofollow>23-Day Course Plan</a> of <a href=https://pragmaticstudio.com rel=nofollow>The Pragmatic Studio</a>'s <a href=https://pragmaticstudio.com/courses/ruby rel=nofollow>Ruby Programming</a> course.</p><h2>Attributes</h2><ul><li>Attributes are private:<pre><code class=ruby> > class Cls
?>   def initialize(param)
?>     @param = param
?>   end
=> :initialize

 > inst = Cls.new("arg")
=> #&lt;Cls:0x0000564dda0a9ff0 @param="arg">
 > inst.param
 NoMethodError (undefined method `param' for #&lt;Cls:0x0000564dda0a9ff0 @param="arg">)
</code></pre></li><li>Define a getter method (the accessor method) to read attributes:<pre><code class=ruby> > class Cls
?>   def initialize(param)
?>     @param = param
?>   end
?>
?>   def param
?>     @param
?>   end
=> :param

 > inst = Cls.new("arg")
=> #&lt;Cls:0x0000564dda0a9ff0 @param="arg">
 > inst.param
=> "arg"
</code></pre></li><li>Or use the <code>attr_reader</code> macro to auto-generate a getter method:<pre><code class=ruby> > class Cls
?>   attr_reader :param # :param is a symbol that references
?>                      # the instance variable @param
?>
?>   def initialize(param)
?>     @param = param
?>   end
=> :initialize

 > inst = Cls.new("arg")
=> #&lt;Cls:0x0000564dda0a9ff0 @param="arg">
 > inst.param
=> "arg"
</code></pre></li><li>Attributes cannot be directly modified:<pre><code class=ruby>?> inst.param = "new arg"
NoMethodError (undefined method `param=' for #&lt;Cls:0x0000564dda0a9ff0 @param="arg">)
</code></pre></li><li>Define a setter method (the mutator method) to change the value of instance variables:<pre><code class=ruby> > class Cls
?>   def initialize(param)
?>     @param = param
?>   end
?>
?>   def param=(new_param)
?>     @param = new_param
?>   end
=> :param=

 > inst = Cls.new("arg")
=> #&lt;Cls:0x0000564dda0a9ff0 @param="arg">
 > inst.param = "new arg"
=> "new arg"
</code></pre></li><li>Or use the <code>attr_writer</code> macro to auto-generate a setter method:<pre><code class=ruby> > class Cls
?>   attr_writer :param # :param is a symbol that references
?>                      # then instance variable @param
?>
?>   def initialize(param)
?>     @param = param
?>   end
=> :initialize

 > inst = Cls.new("arg")
=> #&lt;Cls:0x0000564dda0a9ff0 @param="arg">
 > inst.param = "new arg"
=> "new arg"
</code></pre></li><li>Or use the <code>attr_accessor</code> macro to auto-generate both getter and setter methods:<pre><code class=ruby> > class Cls
?>   attr_accessor :param # :param is a symbol that references
?>                        # the instance variable name @param
?>
?>   def initialize(param)
?>     @param = param
?>   end
=> :initialize

 > inst = Cls.new("arg")
=> #&lt;Cls:0x0000564dda0a9ff0 @param="arg">
 > inst.param
=> "arg"
 > inst.param = "new arg"
=> "new arg"
</code></pre></li><li>Use virtual attributes to avoid unnecessary instance variables:<pre><code class=ruby> > class Cls
?>   def va_param                # virtual attribute (getter)
?>     @va_param
?>   end
?>
?>   def va_param=(new_va_param) # virtual attribute (setter)
?>     @va_param = new_va_param
?>   end
?>
?>   def to_s
?>     "#&lt;class=\"#{self.class.name} @va_param=\"#{@va_param}\">"
?>   end
?> end
=> :to_s

 > inst = Cls.new
=> #&lt;Cls:0x0000564dda0a9ff0>
 > inst.va_param
=> nil
 > inst.va_param = "varg"
=> "varg"
 > inst.va_param
=> "varg"
</code></pre></li></ul><p><strong>Note:</strong> Virtual attributes hide the differences between instance variables and calculated values (UAP).</p><h2>Arrays</h2><ul><li>Create an array instance with the <code>Array</code> class:<pre><code class=ruby> > Array.new
=> []
</code></pre></li><li>Or create an array object with the array literal:<pre><code class=ruby> > []
=> []
</code></pre></li><li>Or use <code>%w</code> or <code>%W</code> wrapped in pair of delimiters:<pre><code class=ruby> > %w[hello\sworld #{1+1.0}] # create an unevaluated array of strings
                             # [] are the delimiters
=> ["hello\\sworld", "\#{1+1.0}"]

 > %W[hello\sworld #{1+1.0}] # create an evaluated array of strings
                             # [] are the delimiters
=> ["hello world", "2.0"]
</code></pre></li><li>Contains an ordered collection of object references:<pre><code class=ruby> > ["foo", 0, false]
=> ["foo", 0, false]
</code></pre></li><li>Each item in an array holds an index that specifies the item position:<pre><code class=ruby> > o = ["foo", 0, false]
=> ["foo", 0, false]

 > o[1] # access the item at 2nd index position
=> 0
</code></pre></li><li>The array index count begins at 0 when doing left-to-right access:<pre><code class=ruby> > o[0]
=> "foo"
</code></pre></li><li>The last array index count ends at -1 when doing right-to-left access:<pre><code class=ruby> > o[-1]
=> false
</code></pre></li><li>Items in an array are also accessible thru ranges:<pre><code class=ruby> > o = ["foo", "bar", "baz"]
=> ["foo", "bar", "baz"]

 > # with [start,count]
 > # (excludes the last specified index position):
 > o[0,1] # access the items
          # from the first index position
          # to but excluding the 2nd index position
=> ["foo"]

 > # with [start...count]
 > # (three dots does same effect as above):
 > o[0...1] # access the items
            # from the first index position
            # to but excluding the 2nd index position
=> ["foo"]

 > # with [start..count]:
 > # (two dots includes the last specified index position):
 > o[0..1] # access the items
           # from the first index position
           # to the 2nd index position
=> ["foo", "bar", "baz"]
</code></pre></li><li>Items in an array can be overwritten thru index:<pre><code class=ruby> > o[0] = "oof" # replace the item
                # on the first index position
                # ("foo" to "oof")
=> "oof"
 > o
=> ["oof", "bar", "baz"]
</code></pre></li><li>Items in an array can also be overwritten thru ranges:<pre><code class=ruby> > o[1,0] = "blah" # insert before the item
                   # on the 2nd index position
                   # ("oof", "bar" to "oof", "blah", "bar")
=> "blah"
 > o
=> ["oof", "blah", "bar", "baz"]

 > o[1,2] = "halbrab" # insert before the item
                      # on the 2nd index position
                      # then replace the next 2
                      # items after that
                      # ("blah", "bar" to "halbrab")
=> "halbrab"
 > o
=> ["oof", "halbrab", "baz"]

 > o[1,2] = ["foo", "bar"] # insert before the item
                           # on the 2nd index position
                           # then replace the next 2
                           # items after that with a
                           # flattened array items
                           # ("halbrab", "baz" to
                           # "foo", "bar")
=> ["foo", "bar"]
 > o
=> ["oof", "foo", "bar"]

 > o[0...1] = [] # remove the items
                 # from the first index position
                 # to but excluding the 2nd index position
                 # ("oof", "foo" to "foo")
=> []
 > o
=> ["foo", "bar"]

 > o[0..1] = [] # remove the items
                # from the first index position
                # to the 2nd index position
                # ("foo", "bar" to [])
=> []
 > o
=> []
</code></pre></li><li>Gaps in arrays are automatically filled with <code>nil</code> object:<pre><code class=ruby> > o = []
=> []
 > o[1] = "bar"
=> "bar"
 > o
=> [nil, "bar"]
</code></pre></li><li>Use the <code>push</code> and <code>pop</code> methods to implement LIFO (Last In, First Out):<pre><code class=ruby> > o = ["foo", "bar"]
=> ["foo", "bar"]

 > o.push("baz") # add item after the last index position
                 # (append)
=> ["foo", "bar", "baz"]

 > o.pop         # remove the item in the last index position
=> "baz"
 > o
=> ["foo", "bar"]
</code></pre></li><li>Or use the <code>&lt;&lt;</code> method (the left shift bitwise operator) to append or concatenate:<pre><code> > o &lt;&lt; "baz"
=> ["foo", "bar", "baz"]

 > # strings also have this method:
 > "hello" &lt;&lt; " world"
=> "hello world"
</code></pre></li><li>Use the <code>shift</code> and <code>unshift</code> methods to implement FIFO (First In, First Out):<pre><code class=ruby> > o = ["bar", "baz"]
=> ["bar", "baz"]

 > o.unshift("foo") # add item before the first index position
                    # (prepend)
=> ["foo", "bar", "baz"]
</code></pre></li><li>Use the <code>first</code> and <code>last</code> methods to access the first and last indices:<pre><code class=ruby> > o = ["foo", "bar", "baz"]
=> ["foo", "bar", "baz"]

 > o.first # access the first index position
=> "foo"

 > o.last  # access the last index position
=> "baz"
</code></pre></li><li>Use the <code>size</code> method to get the length of an array:<pre><code class=ruby> > o.size
=> 3
</code></pre></li><li>Use the <code>each</code> method to loop items in an array:<pre><code> > o.each do |item| # item is local to do-end block's scope
?>   puts item
?> end
foo
bar
baz
=> ["foo", "bar", "baz"]

 > o.each { |item| puts item } # or with braces ({})
foo
bar
baz
=> ["foo", "bar", "baz"]

 > item                        # variable item do not exist
                               # outside loop
NameError (undefined local variable or method `item' for main:Object)
</code></pre></li><li>Use <code>(n..n)</code> to create an array with a range of numbers:<pre><code class=ruby> > (1..3).to_a
=> [1, 2, 3]
</code></pre></li><li>Use the <code>sample</code> method to pick an item randomly in an array:<pre><code class=ruby> > [1, 2, 3].sample
=> 2
</code></pre></li></ul><p><strong>Notes:</strong></p><ul><li>Use brackets (<code>[]</code>) during assignments</li><li>Use brackets (<code>[]</code>) as delimiters on <code>%i</code>, <code>%I</code>, <code>%w</code> and <code>%W</code> literals</li><li>Use the <code>do-end</code> block to loop multi-lined blocks</li><li>Use braces (<code>{}</code>) to loop single-lined blocks</li></ul><h2>Objects Interacting</h2><ul><li>Instances can interact with other instances:<pre><code class=ruby> > class Cls1
?>   attr_accessor :param
?>
?>   def initialize(param)
?>     @param = param
?>   end
?> end
=> :initialize

 > class Cls2
?>   def initialize
?>     @params = []
?>   end
?>
?>   def add_param(new_param)
?>     @params &lt;&lt; new_param
?>   end
?>
?>   def params
?>     @params.each { |param| puts param }
?>   end
?> end
=> :params

 > inst_1 = Cls1.new("arg")
=> #&lt;Cls1:0x000055eed1ae40f0 @param="arg">

 > inst_2 = Cls2.new
=> #&lt;Cls2:0x000055eed169a670 @params=[]>

 > inst_2.add_param(inst_1)
=> [#&lt;Cls1:0x000055eed1ae40f0 @param="arg">]

 > inst_2.params
#&lt;Cls1:0x000055eed1ae40f0>
=> [#&lt;Cls1:0x000055eed1ae40f0 @param="arg">]
</code></pre></li><li>Interacting objects do not create new objects but refers to original references:<pre><code class=ruby> > inst_1.param = "new arg"
=> "new arg"

 > inst_2.params
#&lt;Cls1:0x000055eed1ae40f0>
=> [#&lt;Cls1:0x000055eed1ae40f0 @param="new arg">]
</code></pre></li></ul><p><strong>Note:</strong> This lesson demonstrated encapsulation.</p><h2>Separate Source Files</h2><ul><li>Separate classes with its own file:<pre><code class=shell>$ echo '
class Cls1
end
' > cls_1.rb

$ echo '
class Cls2
end
' > cls_2.rb
</code></pre></li><li>Use the <code>require</code> or <code>require_relative</code> methods to import other Ruby programs:<pre><code class=ruby>require "http"           # import an external package

require_relative "cls_1" # import a relative file
</code></pre></li><li>Use the <code>__FILE__ == $0</code> condition to prevent evaluation of code when file is imported:<pre><code class=shell>$ echo '
if __FILE__ == $0 # or $PROGRAM_NAME
  puts "#{__FILE__} was executed directly from shell."
end
' > cls_1.rb

$ echo '
require_relative "cls_1"
puts "I am just importing cls_1."
' > cls_2.rb

$ ruby cls_1.rb
cls_1.rb was executed directly from shell.

$ ruby cls_2.rb

I am just importing cls_1.
</code></pre></li></ul><p><strong>Notes:</strong></p><ul><li>Naming is similar to variables followed by <code>.rb</code> extension</li><li>This lesson demonstrated a program structure</li></ul><h2>Unit Testing</h2><h3 id=rspec>RSpec</h3><ul><li>Install <a href=https://rspec.info rel=nofollow>RSpec</a>:<pre><code class=shell>$ gem install rspec
</code></pre></li></ul><h3 id=source_and_test_files>Source and test files</h3><ul><li>Create the source file:<pre><code class=shell>$ echo '
class Cls
end
' > cls.rb
</code></pre></li><li>Create the test file:<pre><code class=shell>$ echo '
' > cls_spec.rb
</code></pre></li></ul><p><strong>Note:</strong> Test file name is similar to source file with <code>_spec</code> suffix (e.g. <code>cls_spec.rb</code>).</p><h3 id=bdd>BDD</h3><p>BDD is higher level than TDD that tests behavior, focusing on the business value:</p><ul><li>Import the source file in the test file:<pre><code class=ruby># cls_spec.rb:
require_relative "cls"
</code></pre></li><li>Use the <code>describe</code> block to define an example group (a collection of tests):<pre><code class=ruby># cls_spec.rb:
require_relative "cls"

describe Cls do
end
</code></pre></li><li>Use the <code>context</code> block to separate tests from different contexts of same state:<pre><code class=ruby># cls_spec.rb:
require_relative "cls"

describe Cls do
  context "with default values" do
  end

  context "with specified values" do
  end
end
</code></pre></li><li>Use the <code>it</code> block to define an example (a test case):<pre><code class=ruby># cls_spec.rb:
require_relative "cls"

describe Cls do
  context "with the default value" do
    it "is an empty string"              # a pending test
  end

  context "with a specified value" do
    it "is with the value of \"arg\"" do # an empty test
    end
  end
end
</code></pre></li><li>Use the <code>expect</code> method to verify a condition is met:<pre><code class=ruby># cls_spec.rb:
require_relative "cls"

describe Cls do
  context "with the default value" do
    it "is an empty string"
  end

  context "with a specified value" do
    it "is with the value of \"arg\"" do
      expect(Cls.new("arg").param).to eq("arg")
    end
  end
end
</code></pre></li><li>Use the <code>rspec</code> command to run the test with the test file as argument: <br/><strong>Note:</strong> The first test must be failing test (red).<pre><code class=shell>$ rspec cls_spec.rb

*F

Pending: (Failures listed here are expected and do not affect your suite's status)

  1) Cls with the default value is an empty string
     # Not yet implemented
     # ./cls_spec.rb:5
...
</code></pre></li><li>Use the <code>-f d</code> argument to format the output with group and example names:<pre><code class=shell>$ rspec cls_spec.rb -f d

Cls
  with the default value
    is an empty string (PENDING: Not yet implemented)
  with a specified value
    is with the value of "arg" (FAILED - 1)

Pending: (Failures listed here are expected and do not affect your suite's status)

  1) Cls with the default value is an empty string
     # Not yet implemented
     # ./cls_spec.rb:5
...
</code></pre></li><li>Update the source file to make the failing test pass:<pre><code class=ruby># cls.rb:
class Cls
  def initialize(param)
    @param = param
  end

  def param
    @param
  end
end
</code></pre></li><li>Run the test again: <br/><strong>Note:</strong> The next tests must aim to pass the test (green).<pre><code class=shell>$ rspec cls_spec.rb -f d

Cls
  with the default value
    is an empty string (PENDING: Not yet implemented)
  with a specified value
    is with the value of "arg"

Pending: (Failures listed here are expected and do not affect your suite's status)

  1) Cls with the default value is an empty string
     # Not yet implemented
     # ./cls_spec.rb:5

...
</code></pre></li><li>Update the test file and the source file: <br/><strong>Note:</strong> The source and test files must be updated after the test passed (refactor).<ul><li>Update the source file:<pre><code class=ruby># cls.rb:
class Cls
  attr_reader :param

  def initialize(param)
    @param = param
  end
end
</code></pre></li><li>Update the test file:<pre><code class=ruby># cls_spec.rb:
require_relative "cls"

describe Cls do
  context "with the default value" do
    it "is an empty string"
  end

  context "with a specified value" do
    it "is with the value of \"arg\"" do
      param = "arg"
      instance = Cls.new(param)
      expect(instance.param).to eq(param)
    end
  end
end
</code></pre></li></ul></li><li>Run the test again to make sure nothing broke after refactoring:<pre><code class=shell>$ rspec cls_spec.rb -f d

Cls
  with the default value
    is an empty string (PENDING: Not yet implemented)
  with a specified value
    is with the value of "arg"

Pending: (Failures listed here are expected and do not affect your suite's status)

  1) Cls with the default value is an empty string
     # Not yet implemented
     # ./cls_spec.rb:5
...
</code></pre></li><li>Do the same thing for the pending test:<ol><li>Test file (<code>cls_spec.rb</code>):<pre><code class=ruby>...
    context "with the default value" do
        it "is an empty string" do
          param = ""
          instance = Cls.new
          expect(instance.param).to eq(param)
        end
    end
</code></pre></li><li>Source file (<code>cls.rb</code>):<pre><code class=ruby>...
  def initialize(param="")
</code></pre></li><li>Run test:<pre><code class=shell>$ spec cls_spec.rb -f d

Cls
  with the default value
    is an empty string
  with a specified value
    is with the value of "arg"

Finished in 0.00155 seconds (files took 0.0818 seconds to load)
2 examples, 0 failures
</code></pre></li></ol></li><li>Use the <code>before</code> hook block to setup reusable code: <br/><strong>Note:</strong> <code>before</code> uses <code>:each</code> by default (e.g. <code>before(:each)</code>).<pre><code class=ruby># cls_spec.rb:
require_relative "cls"

describe Cls do
  before do
    @instance = Cls.new
  end

  context "with the default value" do
    before do
      @param = ""
    end

    it "is an empty string" do
      expect(@instance.param).to eq(@param)
    end
  end

  context "with a specified value" do
    before do
      @param = "arg"
      @instance = Cls.new(@param)
    end

    it "is with the value of \"arg\"" do # an empty test
      expect(@instance.param).to eq(@param)
    end
  end
end
</code></pre></li></ul><p><strong>Note:</strong> Test and source files must only refactor the relevant codes it used for testing.</p><h2>Conditionals and TDD</h2><h3 id=conditionals>Conditionals</h3><ul><li>Use the <code>if</code> conditional expression to execute code if the condition is truthy:<pre><code class=ruby> > x = 1

 > if x == 1
?>   "#{x} == 1"
?> elsif x &lt; 1
?>   "#{x} &lt; 1"
?> else
?>   "#{x} is unknown"
?> end
=> "1 == 1"

 > # Or in one-line for single condition:
 > "#{x} == 1" if x == 1
=> "1 == 1"
</code></pre></li><li>Use the <code>unless</code> conditional expression to execute code if the condition is falsy:<pre><code class=ruby> > x = 0

 > unless x == 1
?>   "#{x} is unknown"
?> else
?>   "#{x} == 1"
?> end
=> "0 is unknown"

 > # Or in one-line for single condition:
 > "#{x} is unknown" unless x == 1
=> "0 is unknown"
</code></pre></li><li>Use the ternary operation (<code>? :</code>) for one-line <code>if-else</code> condition:<pre><code class=ruby> > x = 1

 > x == 1 ? "#{x} == 1" : "#{x} is unknown"
=> "1 == 1"
</code></pre></li><li>Use the <code>case</code> conditional expression for multiple conditions:<pre><code class=ruby> > x = 1

# case without expression:
 > case
 > when x == 1
?>   "#{x} == 1"
?> when x &lt; 1
?>   "#{x} &lt; 1"
?> else
?>   "#{x} is unknown"
?> end
=> "1 == 1"

# case with expression:
 > case x
 > when 1
?>   "#{x} == 1"
?> when -1, 0
?>   "#{x} &lt; 1"
?> when 2..10
?>   "#{x}..10"
?> else
?>   "#{x} is unknown"
?> end
=> "1 == 1"
</code></pre></li></ul><p><strong>Notes:</strong></p><ul><li>The <code>then</code> keyword is optional</li><li><code>false</code> and <code>nil</code> are the only falsy values, the rest are truthy</li><li>This lesson demonstrated branching</li></ul><h3 id=tdd>TDD</h3><ol><li>Create a test that fails (red):<ul><li>Create the test:<pre><code class=ruby># cls_spec.rb:
require_relative "cls"

describe Cls do
  context "with default #param" do
    it "is an empty string" do
      expect(Cls.new.param).to eq("")
    end
  end
end
</code></pre></li></ul></li><li>Run the test: <br/><strong>Note:</strong> The dot (<code>.</code>) will recursively execute all the test files.<pre><code class=shell>$ rspec . -f d

Cls
  with default #param
    is an empty string (FAILED - 1)

Failures:

  1) Cls with default #param is an empty string
     Failure/Error: expect(Cls.new.param).to eq("")

       expected: ""
            got: nil

       (compared using ==)
     # ./cls_spec.rb:7:in `block (3 levels) in &lt;top (required)>'

Finished in 0.01628 seconds (files took 0.0589 seconds to load)
1 example, 1 failure

Failed examples:

rspec ./cls_spec.rb:6 # Cls with default #param is an empty string
</code></pre></li><li>Make the test pass (green):<ul><li>Create the source:<pre><code class=ruby># cls.rb:
class Cls
  def initialize(param="")
    @param = param
  end

  def param
    @param
  end
end
</code></pre></li><li>Run the test:<pre><code class=shell>$ rspec . -f d

Cls
  with default #param
    is an empty string

Finished in 0.00112 seconds (files took 0.07088 seconds to load)
1 example, 0 failures
</code></pre></li></ul></li><li>Refactor the files (refactor):<ul><li>Refactor the test file:<pre><code class=ruby># cls_spec.rb:
require_relative "cls"

describe Cls do
  before do
    @param = ""
    @instance = Cls.new
  end

  context "with default #param" do
    it "is an empty string" do
      expect(@instance.param).to eq(@param)
    end
  end
end
</code></pre></li><li>Refactor the source file:<pre><code class=ruby># cls.rb:
class Cls
  attr_accessor :param

  def initialize(param="")
    @param = param
  end
end
</code></pre></li><li>Run the test to make sure the test still works as expected:<pre><code class=shell>$ rspec . -f d

Cls
  with default #param
    is an empty string

Finished in 0.00105 seconds (files took 0.06669 seconds to load)
1 example, 0 failures
</code></pre></li></ul></li></ol><h3 id=stubbing>Stubbing</h3><ul><li>Use the <code>stub</code> method to return a pre-defined value of a yet-to-be-developed code:<ul><li>The test file:<pre><code class=ruby># cls_spec.rb:
require_relative "cls"

describe Cls do
  context "with default #param" do
    it "is an empty string" do
      allow_any_instance_of(Cls).to receive(:param).and_return("")
      expect(Cls.new.param).to eq("")
    end
  end
end
</code></pre></li><li>The source file:<pre><code class=ruby># cls.rb:
class Cls
  def param
  end
end
</code></pre></li><li>Run the test:<pre><code class=shell>$ rspec . -f d

Cls
  with default #param
    is an empty string

Finished in 0.00711 seconds (files took 0.08121 seconds to load)
1 example, 0 failures
</code></pre></li></ul></li></ul><p>Let's continue to the third part: <a href=ruby-programming-part-3 rel=nofollow>Ruby Programming: Part 3</a>.</p> </div> </div> <div class=pagination> <a href=/blog/ruby-programming-part-3 class="btn btn-outline-secondary previous"> <i class="fas fa-angle-left"> </i> Ruby Programming: Part 3 </a> <div class=separator> <i class="fas fa-yin-yang"> </i> </div> <a href=/blog/ruby-programming-part-1 class="btn btn-outline-secondary next">Ruby Programming: Part 1 <i class="fas fa-angle-right"> </i> </a> </div> <hr/> <div class=post-comments> <h2>Comments</h2> <div id=disqus_thread> </div> <script>var disqus_config=function(){this.page.url="https://ejelome.com/blog/ruby-programming-part-2",this.page.identifier="Ruby Programming: Part 2"};!function(){var e=document,t=e.createElement("script");t.src="//ejelome.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)}()</script> <noscript>Please enable JavaScript to view the <a href=//disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a> </noscript> </div> </div> </div> </div> <div class=footer> <p>Copyright © 2019 <a href=/ >ejelome</a>. Some rights reserved. </p> </div> <script src=/js/scripts.js></script> </body> </html> 